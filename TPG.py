#!/usr/bin/python


#..........................................................!
#                                                         ! !
# Warning: This file was automatically generated by TPG  ! | !
# Do not edit this file unless you know what you do.    !  |  !
#                                                      !   @   !
#.....................................................!!!!!!!!!!!



###########################################################
# Toy Parser Generator generated by TPG                   #
# TPG (c) Christophe Delord - 2001-2002                   #
#                                                         #
# For further information about TPG, please visit         #
# http://christophe.delord.free.fr                        #
# or contact the author at                                #
# mailto:christophe.delord@free.fr                        #
#                                                         #
# This program is free for personal use only. Be aware    #
# that this is only a beta release. It's use is at your   #
# own risks.                                              #
# People who will find bugs are pleased to send to the    #
# author the grammar that fails and a short description   #
# of the problem. Feel free to contact the author for     #
# any other request or desired evolution of TPG.          #
#                                                         #
# You can freely redistribute this software as long as    #
# you do not modify it. All documentations and copyright  #
# notices should be delivered with this software.         #
# If this is not the case, please inform the author and   #
# get a complete and recent package of this software on   #
# the author's home page.                                 #
#                                                         #
# For commercial use the license will cost about 75 euros #
# per machine and per generated parser.                   #
# Since this is still a beta version, it's commercial     #
# use is free but time limited (one month free).          #
# For personal or educational use a 10 euro license per   #
# user will be appreciated but not compulsory.            #
# However any financial support is welcome to encourage   #
# the author to improve this software.                    #
#                                                         #
# Happy TPG'ing                                           #
#                                                         #
# Christophe Delord.                                      #
#                                                         #
###########################################################

__version__ = (0, 1, 2)

###########################################################
# History                                                 #
# #######                                                 #
#                                                         #
# v 0.1.2 - New features                                  #
#           * distinction between lexical and syntactic   #
#             rules                                       #
#           * mark definition and text extraction         #
#         - Bug fix                                       #
#           * code now delimited by { {...} } (otherwise  #
#             symbol < <code> > was recognize as symbol   #
#             with <code> as attribute                    #
#                                                         #
# v 0.1.1 - Some bug fixes                                #
#             a b was recognized as if b was a param of a #
#                                                         #
# v 0.1 - Initial version                                 #
#                                                         #
###########################################################

# Bug in sre:
#	when regexp = "< <.*?> >" and string is "< <a... lots of time> >"
#	=> RuntimeError: maximum recursion limit exceeded
# this works fine with pre

# TODO: Penser à signaler le bug (bug ?)

importDef='''
import pre
'''
exec(importDef)

import sys
import string

NodeDef = r'''
class Node(list):
	""" Base class for AST nodes

	An AST node is like a list.

	Reserved method names :
		init : __init__ customization
	Reserved attribute names :
		line : line of the current token in the input stream
		env  : pointer to the parser object containing global variables (global for nodes)
	"""
	def __init__(self, line, env, *args):
		list.__init__(self)
		self.line = line
		self.env = env
		self += args
		apply(self.init,args)
	def init(self, *args):
		pass
	def __str__(self):
		return "%s(%s)"%(self.__class__.__name__,','.join(map(str,self)))
'''
exec(NodeDef)

ToyParserDef = r'''
class ToyParser:
	""" Base class for all Toy Parsers

	Reserved method and attribute names :
		init
		setInput
		line
		error
		check
		Parse
		tgp_*
	Reserved local variable names (in methods) :
		tpg_*
	"""

	class tpg_Error:
		def __init__(self, line):
			self.line = line
		def __str__(self):
			return '%d: Syntax error'%self.line

	class tpg_Pos:
		def __init__(self, pos=0, line=1):
			self.pos = pos
			self.line = line

	def __init__(self, *args):
		self.tpg_regexps = {}
		apply(self.init,args)

	def init(self):
		pass

	def setInput(self, input):
		self.tpg_input = input
		self.line= 0

	def error(self, p):
		raise self.tpg_Error(p.line)

	def tpg_eat(self, p0, regexp, split=0):
		""" skip* lex_eat """
		p1, = self.tpg_lex_skip(p0)
		return self.tpg_lex_eat(p1, regexp, split)

	def tpg_lex_skip(self, p0):
		""" skip* """
		while 1:
			try:
				p1, = self.skip(p0)
				p0 = p1
			except self.tpg_Error:
				p1 = p0
				break
			except AttributeError:
				p1 = p0
				break
		return p1,

	def tpg_lex_eat(self, p0, regexp, split=0):
		try:
			r = self.tpg_regexps[regexp]
		except KeyError:
			r = pre.compile(regexp)
			self.tpg_regexps[regexp] = r
		token = r.match(self.tpg_input, p0.pos)
		if token:
			self.line = p0.line+self.tpg_input.count('\n', p0.pos, token.end())
			p1 = self.tpg_Pos(token.end(), self.line)
			if split == 0: return p1,
			if split == 1: return p1, token.group()
			if split == 2: return p1, token.groups()
		return self.error(p0)

	def check(self, cond):
		if not cond: raise self.tpg_Error(self.line)

	def Parse(self, symbol, input, *args):
		self.setInput(input)
		return apply(getattr(self,symbol), [self.tpg_Pos()]+list(args))[1]
'''
exec(ToyParserDef)

emptyLine = pre.compile(r'\s*$')
startSpaces = pre.compile(r'\s*')

def unindent(text):
	""" Suppression de l'indentation commune
	"""
	lines = text.splitlines()
	common_indent = None
	for line in lines:
		if emptyLine.match(line): continue
		indent = startSpaces.match(line)
		if indent:
			current_indent = indent.group()
			if common_indent is None:
				common_indent = current_indent
			else:
				for i in xrange(len(common_indent)):
					try:
						if common_indent[i] != current_indent[i]:
							common_indent = common_indent[:i]
							break
					except IndexError:
						break
	if common_indent is None: common_indent = ""
	def trim_line(line):
		line = emptyLine.sub('',line)
		return line[len(common_indent):]
	return "\n".join(map(trim_line,lines))

def reindent(indent, text):
	tab = '\t'*indent
	return	"\n".join([tab + line for line in text.splitlines()])+"\n"

def if_(cond, true, false):
	if cond:
		return true
	else:
		return false

TPG_Warning = """

#..........................................................!
#                                                         ! !
# Warning: This file was automatically generated by TPG  ! | !
# Do not edit this file unless you know what you do.    !  |  !
#                                                      !   @   !
#.....................................................!!!!!!!!!!!

"""

class Parsers(Node):
	def init(self, options):
		self.options = options
	def genCode(self, indent=0):
		return "\n".join([parser.genCode(indent) for parser in self])+"\n"

class Options(Node):
	def init(self):
		self.options = {'runtime':1, 'magic':None}
	def set(self, opt, val):
		self.options[opt] = val
	def get(self, opt):
		try:
			return self.options[opt]
		except KeyError:
			return None
	def genCode(self, indent):
		code = ""
		magic = self.get('magic')
		if magic:
			code += magic
		code += TPG_Warning
		if self.get('runtime'):
			code += importDef
			code += NodeDef
			code += ToyParserDef
		return reindent(indent, code)

class Parser(Node):
	def init(self, id, ids):
		self.parserName = id
		self.parserBase = ids
		if _v>=1: print "parser %s(%s):"%(id.name,', '.join([i.name for i in ids]))
	def header(self, indent):
		name = self.parserName.genCode()
		toyParser = ToyParser.__name__
		base = self.parserBase.genCode()
		return reindent(indent, "class %s(%s, %s):\n"%(name,toyParser,base))
	def genCode(self, indent):
		self.items = self[2:]
		return self.header(indent)+"\n".join([item.genCode(indent+1) for item in self.items])+"\n"

class Code(Node):
	def init(self, c):
		self.code = unindent(c)
	def genCode(self, indent, X=None, Y=None, lex=None):
		tab = "\t"*indent
		return	reindent(indent, self.code)						\
		+		if_(X and Y and X!=Y,tab+"%s = %s\n"%(Y,X),"")
	def verb(self):
		return ""
	prec = 1
	eater = 0

class Rule(Node):
	def init(self, islex, symbol, expr):
		self.lex = if_(islex, 'lex_', '')
		self.s = symbol
		self.e = expr
		if _v>=2: print self.verb()
	def verb(self):
		return if_(self.lex,'lex ','')+"%s -> %s ."%(self.s.verb(), self.e.verb())
	def genCode(self, indent):
		self.env.initVar()
		X, Y = self.env.newVar(2)
		if self.s.getName() == 'START':
			tab = "\t"*indent
			axiom =	tab		+"def __call__(self, input, *args):\n"									\
					+tab	+"\t"	+"self.setInput(input)\n"										\
					+tab	+"\t"	+"return apply(self.START, [self.tpg_Pos()]+list(args))[1]\n"	\
					+ "\n"
		else:
			axiom = ""
		doc = "\t"*(indent+1)+'"""%s"""\n'%self.verb()
		return axiom+self.s.genDef(indent,X,Y)+doc+self.e.genCode(indent+1,X,Y,self.lex)+self.s.genRet(indent+1,X,Y)

class Ident(Node):
	def init(self, id):
		self.name = id
	def genCode(self):
		return self.name
	def genRetVal(self):
		return self.name
	def verb(self):
		return self.name
	def getSplit(self):
		return 1

class Idents(Node):
	def genCode(self):
		return ",".join([id.genCode() for id in self])
	def genRetVal(self):
		if len(self)==0:
			return ""
		else:
			return "(%s,)"%','.join([a.genCode() for a in self])
	def getSplit(self):
		if len(self)==0:
			return 0
		else:
			return 2

class Ast(Node):
	def init(self, id, args):
		self.functor, self.args = id, args
	def genRetVal(self):
		return self.genCode()
	def genCode(self):
		return "%s(self.line, self, %s)"%(self.functor.genCode(), ', '.join([a.genCode() for a in self.args]))

class Args(Node):
	pass

class Tuple(Node):
	def genCode(self):
		return "(%s,)"%(', '.join([a.genCode() for a in self]))
	def genRetVal(self):
		return self.genCode()

class Extract(Node):
	def init(self, start, end):
		self.start, self.end = start.name, end.name
	def genCode(self):
		return "self.tpg_input[%s.pos:%s.pos]"%(self.start, self.end)
	def genRetVal(self):
		return self.genCode()

class MakeAST(Node):
	def init(self, id, ast):
		self.var, self.ast = id, ast
	def genCode(self, indent, X, Y, lex):
		tab = "\t"*indent
		return	tab+"%s = %s\n"%(self.var.genCode(),self.ast.genCode())	\
		+		if_(X!=Y,tab+"%s = %s\n"%(Y,X),"")
	def verb(self):
		return ""
	prec = 1
	eater = 0

class AddAST(Node):
	def init(self, id, ast):
		self.var, self.ast = id, ast
	def genCode(self, indent, X, Y, lex):
		tab = "\t"*indent
		return	tab+"%s.append(%s)\n"%(self.var.genCode(),self.ast.genCode())	\
		+		if_(X!=Y,tab+"%s = %s\n"%(Y,X),"")
	def verb(self):
		return ""
	prec = 1
	eater = 0

class Mark(Node):
	def init(self, id):
		self.var = id
	def verb(self):
		return ""
	def genCode(self, indent, X, Y, lex):
		return "\t"*indent+"%s = %s\n"%(self.var.name, Y)
	prec = 1
	eater = 0

class BeginMark(Mark):
	def genCode(self, indent, X, Y, lex):
		tab = "\t"*indent
		return	tab+	if_(lex, "%s = %s\n"%(Y, X), "%s, self.tpg_lex_skip(%s)\n"%(Y, X))	\
				+tab+	"%s = %s\n"%(self.var.name, Y)
	eater = 1	# pour skip* dans les règles syntaxiques

class EndMark(Mark):
	pass

def escape(st, chars):
	s = ""
	for c in st:
		if c in chars:
			s += '\\'+c
		else:
			s += c
	return s

class Re(Node):
	def init(self, s, val):
		self.re, self.ret = escape(s,"'"), val
	def genCode(self, indent, X, Y, lex):
		return "\t"*indent + "%s, %s = self.tpg_%seat(%s, r'%s', %s)\n"%(Y, self.genRetVal(), lex, X, self.re, self.ret.getSplit())
	def genRetVal(self):
		return self.ret.genRetVal()
	def verb(self):
		return "'%s'"%self.re
	prec = 1
	eater = 1

class Symbol(Node):
	def init(self, id, args, values):
		self.name, self.params, self.ret = id, args, values
	def getName(self):
		return self.name.genCode()
	def genDef(self, indent, X, Y):
		return "\t"*indent + "def %s(self, %s, %s):\n"%(self.name.genCode(), X, ', '.join([a.genCode() for a in self.params]))
	def genCode(self, indent, X, Y, lex):
		tab = "\t"*indent
		code = ''
		if not lex and self.env.isLex(self.name.name):
			Z = self.env.newVar()
			code += tab + "%s, = self.tpg_lex_skip(%s)\n"%(Z, X)
			X = Z
		code += tab + "%s, %s = self.%s(%s, %s)\n"%(Y, self.genRetVal(), self.name.genCode(), X,', '.join([a.genCode() for a in self.params]))
		return code
	def genRetVal(self):
		return self.ret.genRetVal()
	def genRet(self, indent, X, Y):
		return "\t"*indent + "return %s, %s\n"%(Y, self.genRetVal())
	def verb(self):
		return self.name.verb()
	prec = 1
	eater = 1

class Alt(Node):
	def init(self, a, b):
		self.a = a
		self.b = b
	def genCode(self, indent, X, Y, lex):
		tab = "\t"*indent
		return	tab+"try:\n"								\
		+				self.a.genCode(indent+1,X,Y,lex)	\
		+		tab+"except self.tpg_Error:\n"				\
		+				self.b.genCode(indent+1,X,Y,lex)
	def verb(self):
		return ' | '.join([i.verb() for i in self])
	prec = 0
	eater = 1

class Seq(Node):
	def genCode(self, indent, X, Y, lex):
		code = ""
		L = []
		n, last = 0, None
		for item in self:
			if item.eater:
				Z = self.env.newVar()
				L.append([item,X,Z])
				X = Z
				last = n
			else:
				L.append([item,X,X])
			n += 1
		if last is not None:
			L[last][2] = Y
			for item in L[last+1:]: item[1] = item[2] = Y
		for item_X_Y in L:
			item, Xi, Yi = tuple(item_X_Y)
			code += item.genCode(indent,Xi,Yi,lex)
		if last is None: code += "\t"*indent + "%s = %s\n"%(Y,X)
		return code
	def verb(self):
		st = ''
		for i in self:
			iv = i.verb()
			if iv:
				if i.prec<self.prec:
					st += if_(st,' ','')+"( %s )"%i.verb()
				else:
					st += if_(st,' ','')+i.verb()
		return st
	prec = 1
	eater = 1

class Rep(Node):
	def init(self, min, max, expr):
		self.m, self.M, self.a = min, max, expr
		m, M = self.m, self.M
		if M!=None:
			self.env.check(m<=M and (m,M)!=(0,0))
	def genCode(self, indent, X, Y, lex):
		tab = "\t"*indent
		m, M = self.m, self.M
		if (m, M) == (0, 1):		# ?
			return	tab+"try:\n"													\
			+					self.a.genCode(indent+1,X,Y,lex)					\
			+		tab+"except self.tpg_Error:\n"									\
			+		tab+"\t"+	"%s = %s\n"%(Y,X)
		elif (m, M) == (0, None):	# *
			return 	tab+"while 1:\n"												\
			+		tab+"\t"+	"try:\n"											\
			+						self.a.genCode(indent+2,X,Y,lex)				\
			+		tab+"\t\t"+		"%s = %s\n"%(X,Y)								\
			+		tab+"\t"+	"except self.tpg_Error:\n"							\
			+		tab+"\t\t"+		"%s = %s\n"%(Y,X)								\
			+		tab+"\t\t"+		"break\n"
		else:						# + and other loops
			n = self.env.newCount()
			X1 = self.env.newVar()
			return	tab+"%s = 0\n"%n												\
			+		tab+"%s = %s\n"%(X1,X)											\
			+		tab+"while "+if_(self.M==None,"1","%s < %s"%(n,self.M))+":\n"	\
			+		tab+"\t"+	"try:\n"											\
			+						self.a.genCode(indent+2,X1,Y,lex)				\
			+		tab+"\t\t"+		"%s += 1\n"%n									\
			+		tab+"\t\t"+		"%s = %s\n"%(X1,Y)								\
			+		tab+"\t"+	"except self.tpg_Error:\n"							\
			+		tab+"\t\t"		"self.check(%s>=%s)\n"%(n,self.m)				\
			+		tab+"\t\t"+		"%s = %s\n"%(Y,X1)								\
			+		tab+"\t\t"+		"break\n"
	def verb(self):
		m, M = self.m, self.M
		if (m, M) == (0, 1): r = '?'
		elif (m, M) == (0, None): r = '*'
		elif (m, M) == (1, None): r = '+'
		elif m == M: r = "{%s}"%m
		else: r = "{%s,%s}"%(if_(m,m,''),if_(M,M,''))
		return "( %s )%s"%(self.a.verb(),r)
	prec = 1
	eater = 1

class TPParser(ToyParser, ):
	
	
	""" Parser for Toy Parser Grammars
	"""
	
	def init(self):
		self.lexs = {}
	
	def initVar(self):
		self.nextVar = 0
		self.nextCount = 0
	
	def newVar(self, n=1):
		if n>1:
			return tuple([self.newVar() for i in xrange(n)])
		else:
			p = "tpg_p%s"%self.nextVar
			self.nextVar += 1
			return p
	
	def newCount(self):
		n = "tpg_n%s"%self.nextCount
		self.nextCount += 1
		return n
	
	def setLex(self, name):
		self.lexs[name] = 1
	
	def isLex(self, name):
		return self.lexs.has_key(name)

	def __call__(self, input, *args):
		self.setInput(input)
		return apply(self.START, [self.tpg_Pos()]+list(args))[1]

	def START(self, tpg_p0, ):
		"""START -> PARSER ."""
		tpg_p1, parsers = self.PARSER(tpg_p0, )
		code=parsers.genCode()
		return tpg_p1, code

	def PARSER(self, tpg_p0, ):
		"""PARSER -> OPTIONS ( CODE )* ( 'parser' IDENT ( '\(' IDENTS '\)' |  ) ':' ( CODE | RULE )* | 'main' ':' ( CODE )* )* '$' ."""
		tpg_p2, opts = self.OPTIONS(tpg_p0, )
		parsers = Parsers(self.line, self, opts)
		while 1:
			try:
				tpg_p3, c = self.CODE(tpg_p2, )
				parsers.append(c)
				tpg_p2 = tpg_p3
			except self.tpg_Error:
				tpg_p3 = tpg_p2
				break
		while 1:
			try:
				try:
					tpg_p7,  = self.tpg_eat(tpg_p3, r'parser', 0)
					tpg_p8, id = self.IDENT(tpg_p7, )
					try:
						tpg_p12,  = self.tpg_eat(tpg_p8, r'\(', 0)
						tpg_p13, ids = self.IDENTS(tpg_p12, )
						tpg_p9,  = self.tpg_eat(tpg_p13, r'\)', 0)
					except self.tpg_Error:
						ids = Idents(self.line, self, )
						tpg_p9 = tpg_p8
					tpg_p10,  = self.tpg_eat(tpg_p9, r':', 0)
					parser = Parser(self.line, self, id, ids)
					while 1:
						try:
							try:
								tpg_p4, c = self.CODE(tpg_p10, )
								parser.append(c)
							except self.tpg_Error:
								tpg_p4, r = self.RULE(tpg_p10, )
								parser.append(r)
							tpg_p10 = tpg_p4
						except self.tpg_Error:
							tpg_p4 = tpg_p10
							break
					parsers.append(parser)
				except self.tpg_Error:
					tpg_p17,  = self.tpg_eat(tpg_p3, r'main', 0)
					tpg_p18,  = self.tpg_eat(tpg_p17, r':', 0)
					while 1:
						try:
							tpg_p4, c = self.CODE(tpg_p18, )
							parsers.append(c)
							tpg_p18 = tpg_p4
						except self.tpg_Error:
							tpg_p4 = tpg_p18
							break
				tpg_p3 = tpg_p4
			except self.tpg_Error:
				tpg_p4 = tpg_p3
				break
		tpg_p1,  = self.tpg_eat(tpg_p4, r'$', 0)
		return tpg_p1, parsers

	def OPTIONS(self, tpg_p0, ):
		"""OPTIONS -> ( 'set' ( '(no)?(runtime)' | 'no(magic)' | 'magic' '=' '.*' ) )* ."""
		opts = Options(self.line, self, )
		while 1:
			try:
				tpg_p3,  = self.tpg_eat(tpg_p0, r'set', 0)
				try:
					try:
						tpg_p1, (no,opt,) = self.tpg_eat(tpg_p3, r'(no)?(runtime)', 2)
						opts.set(opt,not no)
					except self.tpg_Error:
						tpg_p1, (opt,) = self.tpg_eat(tpg_p3, r'no(magic)', 2)
						opts.set(opt,None)
				except self.tpg_Error:
					tpg_p7, opt = self.tpg_eat(tpg_p3, r'magic', 1)
					tpg_p8,  = self.tpg_eat(tpg_p7, r'=', 0)
					tpg_p1, magic = self.tpg_eat(tpg_p8, r'.*', 1)
					opts.set(opt,"#!%s\n"%magic)
				tpg_p0 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p0
				break
		return tpg_p1, opts

	def skip(self, tpg_p0, ):
		"""lex skip -> '\s+' | '#.*' | '//.*' | '\/\*' ccomment '\*\/' ."""
		try:
			try:
				try:
					tpg_p1,  = self.tpg_lex_eat(tpg_p0, r'\s+', 0)
				except self.tpg_Error:
					tpg_p1,  = self.tpg_lex_eat(tpg_p0, r'#.*', 0)
			except self.tpg_Error:
				tpg_p1,  = self.tpg_lex_eat(tpg_p0, r'//.*', 0)
		except self.tpg_Error:
			tpg_p5,  = self.tpg_lex_eat(tpg_p0, r'\/\*', 0)
			tpg_p6,  = self.ccomment(tpg_p5, )
			tpg_p1,  = self.tpg_lex_eat(tpg_p6, r'\*\/', 0)
		return tpg_p1, 

	def ccomment(self, tpg_p0, ):
		"""lex ccomment -> ( '\/\*' ccomment '\*\/' | '\*[^\/]' | '[^\*]' )* ."""
		while 1:
			try:
				try:
					try:
						tpg_p3,  = self.tpg_lex_eat(tpg_p0, r'\/\*', 0)
						tpg_p4,  = self.ccomment(tpg_p3, )
						tpg_p1,  = self.tpg_lex_eat(tpg_p4, r'\*\/', 0)
					except self.tpg_Error:
						tpg_p1,  = self.tpg_lex_eat(tpg_p0, r'\*[^\/]', 0)
				except self.tpg_Error:
					tpg_p1,  = self.tpg_lex_eat(tpg_p0, r'[^\*]', 0)
				tpg_p0 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p0
				break
		return tpg_p1, 

	def CODE(self, tpg_p0, ):
		"""CODE -> '{{((?:.|\n)*?)}}' ."""
		tpg_p1, (c,) = self.tpg_eat(tpg_p0, r'{{((?:.|\n)*?)}}', 2)
		return tpg_p1, Code(self.line, self, c)

	def IDENT(self, tpg_p0, ):
		"""IDENT -> '\w+' ."""
		tpg_p1, id = self.tpg_eat(tpg_p0, r'\w+', 1)
		return tpg_p1, Ident(self.line, self, id)

	def IDENTS(self, tpg_p0, ):
		"""IDENTS -> IDENT ( ',' IDENT )* ."""
		ids = Idents(self.line, self, )
		tpg_p2, id = self.IDENT(tpg_p0, )
		ids.append(id)
		while 1:
			try:
				tpg_p4,  = self.tpg_eat(tpg_p2, r',', 0)
				tpg_p1, id = self.IDENT(tpg_p4, )
				ids.append(id)
				tpg_p2 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p2
				break
		return tpg_p1, ids

	def RULE(self, tpg_p0, ):
		"""RULE -> ( 'lex' DEF_SYMBOL | DEF_SYMBOL ) '->' EXPR '\.' ."""
		try:
			tpg_p6,  = self.tpg_eat(tpg_p0, r'lex', 0)
			lex = 1
			tpg_p2, s = self.DEF_SYMBOL(tpg_p6, )
			self.setLex(s.name.name)
		except self.tpg_Error:
			lex = 0
			tpg_p2, s = self.DEF_SYMBOL(tpg_p0, )
			self.check(s.name.name!='skip')
		tpg_p3,  = self.tpg_eat(tpg_p2, r'->', 0)
		tpg_p4, e = self.EXPR(tpg_p3, )
		tpg_p1,  = self.tpg_eat(tpg_p4, r'\.', 0)
		return tpg_p1, Rule(self.line, self, lex, s, e)

	def DEF_SYMBOL(self, tpg_p0, ):
		"""DEF_SYMBOL -> IDENT DEF_ARGS DEF_VALUES ."""
		tpg_p2, id = self.IDENT(tpg_p0, )
		tpg_p3, args = self.DEF_ARGS(tpg_p2, id)
		tpg_p1, values = self.DEF_VALUES(tpg_p3, id)
		return tpg_p1, Symbol(self.line, self, id, args, values)

	def DEF_ARGS(self, tpg_p0, id):
		"""DEF_ARGS -> '<' IDENTS '>' |  ."""
		try:
			self.check(id.name!='skip')
			tpg_p2,  = self.tpg_eat(tpg_p0, r'<', 0)
			tpg_p3, args = self.IDENTS(tpg_p2, )
			tpg_p1,  = self.tpg_eat(tpg_p3, r'>', 0)
		except self.tpg_Error:
			args = Idents(self.line, self, )
			tpg_p1 = tpg_p0
		return tpg_p1, args

	def DEF_VALUES(self, tpg_p0, id):
		"""DEF_VALUES -> '/' DEF_RET |  ."""
		try:
			self.check(id.name!='skip')
			tpg_p2,  = self.tpg_eat(tpg_p0, r'/', 0)
			tpg_p1, values = self.DEF_RET(tpg_p2, )
		except self.tpg_Error:
			values = Idents(self.line, self, )
			tpg_p1 = tpg_p0
		return tpg_p1, values

	def DEF_RET(self, tpg_p0, ):
		"""DEF_RET -> '<' DEF_TUPLE '>' | DEF_AST | IDENT '\.\.' IDENT | IDENT ."""
		try:
			try:
				try:
					tpg_p2,  = self.tpg_eat(tpg_p0, r'<', 0)
					tpg_p3, values = self.DEF_TUPLE(tpg_p2, )
					tpg_p1,  = self.tpg_eat(tpg_p3, r'>', 0)
				except self.tpg_Error:
					tpg_p1, values = self.DEF_AST(tpg_p0, )
			except self.tpg_Error:
				tpg_p6, start = self.IDENT(tpg_p0, )
				tpg_p7,  = self.tpg_eat(tpg_p6, r'\.\.', 0)
				tpg_p1, end = self.IDENT(tpg_p7, )
				values = Extract(self.line, self, start, end)
		except self.tpg_Error:
			tpg_p1, values = self.IDENT(tpg_p0, )
		return tpg_p1, values

	def DEF_TUPLE(self, tpg_p0, ):
		"""DEF_TUPLE -> DEF_RET ( ',' DEF_RET )* ."""
		t = Tuple(self.line, self, )
		tpg_p2, c = self.DEF_RET(tpg_p0, )
		t.append(c)
		while 1:
			try:
				tpg_p4,  = self.tpg_eat(tpg_p2, r',', 0)
				tpg_p1, c = self.DEF_RET(tpg_p4, )
				t.append(c)
				tpg_p2 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p2
				break
		return tpg_p1, t

	def DEF_AST(self, tpg_p0, ):
		"""DEF_AST -> IDENT '<' DEF_ASTS '>' ."""
		tpg_p2, id = self.IDENT(tpg_p0, )
		tpg_p3,  = self.tpg_eat(tpg_p2, r'<', 0)
		tpg_p4, args = self.DEF_ASTS(tpg_p3, )
		tpg_p1,  = self.tpg_eat(tpg_p4, r'>', 0)
		return tpg_p1, Ast(self.line, self, id, args)

	def DEF_ASTS(self, tpg_p0, ):
		"""DEF_ASTS -> ( DEF_AST_IT ( ',' DEF_AST_IT )* )? ."""
		args = Args(self.line, self, )
		try:
			tpg_p3, a = self.DEF_AST_IT(tpg_p0, )
			args.append(a)
			while 1:
				try:
					tpg_p5,  = self.tpg_eat(tpg_p3, r',', 0)
					tpg_p1, a = self.DEF_AST_IT(tpg_p5, )
					args.append(a)
					tpg_p3 = tpg_p1
				except self.tpg_Error:
					tpg_p1 = tpg_p3
					break
		except self.tpg_Error:
			tpg_p1 = tpg_p0
		return tpg_p1, args

	def DEF_AST_IT(self, tpg_p0, ):
		"""DEF_AST_IT -> DEF_RET ."""
		tpg_p1, ast = self.DEF_RET(tpg_p0, )
		return tpg_p1, ast

	def RE(self, tpg_p0, ):
		"""RE -> string RE_VALUES ."""
		tpg_p2, s = self.string(tpg_p0, )
		tpg_p1, val = self.RE_VALUES(tpg_p2, )
		return tpg_p1, Re(self.line, self, s, val)

	def string(self, tpg_p0, ):
		"""string -> '"([^"]*)"' | '\'([^\']*)\'' ."""
		try:
			tpg_p1, (s,) = self.tpg_eat(tpg_p0, r'"([^"]*)"', 2)
		except self.tpg_Error:
			tpg_p1, (s,) = self.tpg_eat(tpg_p0, r'\'([^\']*)\'', 2)
		return tpg_p1, s

	def RE_VALUES(self, tpg_p0, ):
		"""RE_VALUES -> '/' ( IDENT | '<' IDENTS '>' ) |  ."""
		try:
			tpg_p2,  = self.tpg_eat(tpg_p0, r'/', 0)
			try:
				tpg_p1, val = self.IDENT(tpg_p2, )
			except self.tpg_Error:
				tpg_p5,  = self.tpg_eat(tpg_p2, r'<', 0)
				tpg_p6, val = self.IDENTS(tpg_p5, )
				tpg_p1,  = self.tpg_eat(tpg_p6, r'>', 0)
		except self.tpg_Error:
			val = Idents(self.line, self, )
			tpg_p1 = tpg_p0
		return tpg_p1, val

	def SYMBOL(self, tpg_p0, ):
		"""SYMBOL -> IDENT ARGS VALUES ."""
		tpg_p2, id = self.IDENT(tpg_p0, )
		self.check(id.name!='skip')
		tpg_p3, args = self.ARGS(tpg_p2, )
		tpg_p1, values = self.VALUES(tpg_p3, )
		return tpg_p1, Symbol(self.line, self, id, args, values)

	def ARGS(self, tpg_p0, ):
		"""ARGS -> '<' DEF_TUPLE '>' |  ."""
		try:
			tpg_p2,  = self.tpg_eat(tpg_p0, r'<', 0)
			tpg_p3, args = self.DEF_TUPLE(tpg_p2, )
			tpg_p1,  = self.tpg_eat(tpg_p3, r'>', 0)
		except self.tpg_Error:
			args = Idents(self.line, self, )
			tpg_p1 = tpg_p0
		return tpg_p1, args

	def VALUES(self, tpg_p0, ):
		"""VALUES -> '/' RET |  ."""
		try:
			tpg_p2,  = self.tpg_eat(tpg_p0, r'/', 0)
			tpg_p1, values = self.RET(tpg_p2, )
		except self.tpg_Error:
			values = Idents(self.line, self, )
			tpg_p1 = tpg_p0
		return tpg_p1, values

	def RET(self, tpg_p0, ):
		"""RET -> '<' TUPLE '>' | IDENT ."""
		try:
			tpg_p2,  = self.tpg_eat(tpg_p0, r'<', 0)
			tpg_p3, values = self.TUPLE(tpg_p2, )
			tpg_p1,  = self.tpg_eat(tpg_p3, r'>', 0)
		except self.tpg_Error:
			tpg_p1, values = self.IDENT(tpg_p0, )
		return tpg_p1, values

	def TUPLE(self, tpg_p0, ):
		"""TUPLE -> RET ( ',' RET )* ."""
		t = Tuple(self.line, self, )
		tpg_p2, c = self.RET(tpg_p0, )
		t.append(c)
		while 1:
			try:
				tpg_p4,  = self.tpg_eat(tpg_p2, r',', 0)
				tpg_p1, c = self.RET(tpg_p4, )
				t.append(c)
				tpg_p2 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p2
				break
		return tpg_p1, t

	def EXPR(self, tpg_p0, ):
		"""EXPR -> TERM ( '\|' TERM )* ."""
		tpg_p2, e = self.TERM(tpg_p0, )
		while 1:
			try:
				tpg_p4,  = self.tpg_eat(tpg_p2, r'\|', 0)
				tpg_p1, t = self.TERM(tpg_p4, )
				e = Alt(self.line, self, e, t)
				tpg_p2 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p2
				break
		return tpg_p1, e

	def TERM(self, tpg_p0, ):
		"""TERM -> ( FACT )* ."""
		t = Seq(self.line, self, )
		while 1:
			try:
				tpg_p1, f = self.FACT(tpg_p0, )
				t.append(f)
				tpg_p0 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p0
				break
		return tpg_p1, t

	def FACT(self, tpg_p0, ):
		"""FACT -> RET ( '=' DEF_RET | '-' DEF_RET ) | '!<' IDENT | '!>' IDENT | '!' IDENT | CODE | ATOM REP ."""
		try:
			try:
				try:
					try:
						try:
							tpg_p2, id = self.RET(tpg_p0, )
							try:
								tpg_p4,  = self.tpg_eat(tpg_p2, r'=', 0)
								tpg_p1, ast = self.DEF_RET(tpg_p4, )
								f = MakeAST(self.line, self, id, ast)
							except self.tpg_Error:
								tpg_p6,  = self.tpg_eat(tpg_p2, r'-', 0)
								tpg_p1, ast = self.DEF_RET(tpg_p6, )
								f = AddAST(self.line, self, id, ast)
						except self.tpg_Error:
							tpg_p8,  = self.tpg_eat(tpg_p0, r'!<', 0)
							tpg_p1, id = self.IDENT(tpg_p8, )
							f = BeginMark(self.line, self, id)
					except self.tpg_Error:
						tpg_p10,  = self.tpg_eat(tpg_p0, r'!>', 0)
						tpg_p1, id = self.IDENT(tpg_p10, )
						f = EndMark(self.line, self, id)
				except self.tpg_Error:
					tpg_p12,  = self.tpg_eat(tpg_p0, r'!', 0)
					tpg_p1, id = self.IDENT(tpg_p12, )
					f = Mark(self.line, self, id)
			except self.tpg_Error:
				tpg_p1, f = self.CODE(tpg_p0, )
		except self.tpg_Error:
			tpg_p15, f = self.ATOM(tpg_p0, )
			tpg_p1, f = self.REP(tpg_p15, f)
		return tpg_p1, f

	def REP(self, tpg_p0, f):
		"""REP -> ( '\?' | '\*' | '\+' | '\{' nb ( ',' nb |  ) '\}' )? ."""
		try:
			try:
				try:
					try:
						tpg_p1,  = self.tpg_eat(tpg_p0, r'\?', 0)
						f = Rep(self.line, self, 0, 1, f)
					except self.tpg_Error:
						tpg_p1,  = self.tpg_eat(tpg_p0, r'\*', 0)
						f = Rep(self.line, self, 0, None, f)
				except self.tpg_Error:
					tpg_p1,  = self.tpg_eat(tpg_p0, r'\+', 0)
					f = Rep(self.line, self, 1, None, f)
			except self.tpg_Error:
				tpg_p6,  = self.tpg_eat(tpg_p0, r'\{', 0)
				tpg_p7, m = self.nb(tpg_p6, 0)
				try:
					tpg_p10,  = self.tpg_eat(tpg_p7, r',', 0)
					tpg_p8, M = self.nb(tpg_p10, None)
				except self.tpg_Error:
					M = m
					tpg_p8 = tpg_p7
				tpg_p1,  = self.tpg_eat(tpg_p8, r'\}', 0)
				f = Rep(self.line, self, m, M, f)
		except self.tpg_Error:
			tpg_p1 = tpg_p0
		return tpg_p1, f

	def nb(self, tpg_p0, default):
		"""nb -> '\d+' |  ."""
		try:
			tpg_p1, s = self.tpg_eat(tpg_p0, r'\d+', 1)
			n=string.atoi(s)
		except self.tpg_Error:
			n = default
			tpg_p1 = tpg_p0
		return tpg_p1, n

	def ATOM(self, tpg_p0, ):
		"""ATOM -> SYMBOL | RE | '\(' EXPR '\)' ."""
		try:
			try:
				tpg_p1, a = self.SYMBOL(tpg_p0, )
			except self.tpg_Error:
				tpg_p1, a = self.RE(tpg_p0, )
		except self.tpg_Error:
			tpg_p4,  = self.tpg_eat(tpg_p0, r'\(', 0)
			tpg_p5, a = self.EXPR(tpg_p4, )
			tpg_p1,  = self.tpg_eat(tpg_p5, r'\)', 0)
		return tpg_p1, a




_v = 0

if __name__ == "__main__":
	print "TPG v%s (c) Christophe Delord"%('.'.join(map(str,__version__)))
	try:
		args = sys.argv[1:]
		grammar_file = None
		output_file = None
		while args:
			arg, args = args[0], args[1:]
			if arg == '-o':
				arg, args = args[0], args[1:]
				assert arg.endswith('.py') and not output_file
				output_file = arg
			elif arg.startswith('-v'):
				for c in arg[1:]: assert c=='v'
				_v = len(arg)-1
			else:
				assert arg.endswith('.g') and not grammar_file
				grammar_file = arg
		assert grammar_file
		if not output_file: output_file = grammar_file[:-2]+'.py'
	except AssertionError:
		sys.stderr.write("Syntax: %s [-v] grammar_file.g [-o output_file.py]\n"%sys.argv[0])
	else:
		print "TPG: translating %s to %s"%(grammar_file,output_file)
		f = open(grammar_file, 'r')
		g = open(output_file, 'w')
		g.write(TPParser()(f.read()))
		f.close()
		g.close()
		print "Translation OK"


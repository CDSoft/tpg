#!/usr/bin/python


#..........................................................!
#                                                         ! !
# Warning: This file was automatically generated by TPG  ! | !
# Do not edit this file unless you know what you do.    !  |  !
#                                                      !   @   !
#.....................................................!!!!!!!!!!!


import pre

class Node(list):
	""" Base class for AST nodes

	An AST node is like a list.

	Reserved method names :
		init : __init__ customization
	Reserved attribute names :
		line : line of the current token in the input stream
		env  : pointer to the parser object containing global variables (global for nodes)
	"""
	def __init__(self, line, env, *args):
		list.__init__(self)
		self.line = line
		self.env = env
		self += args
		apply(self.init,args)
	def init(self, *args):
		pass
	def __str__(self):
		return "%s(%s)"%(self.__class__.__name__,','.join(map(str,self)))

class ToyParser:
	""" Base class for all Toy Parsers

	Reserved method and attribute names :
		init
		setInput
		line
		error
		check
		Parse
		tgp_*
	Reserved local variable names (in methods) :
		tpg_*
	"""

	class tpg_Error:
		def __init__(self, line):
			self.line = line
		def __str__(self):
			return '%d: Syntax error'%self.line

	class tpg_Pos:
		def __init__(self, pos=0, line=1):
			self.pos = pos
			self.line = line

	def __init__(self, *args):
		self.tpg_regexps = {}
		apply(self.init,args)

	def init(self):
		pass

	def setInput(self, input):
		self.tpg_input = input
		self.line= 0

	def error(self, p):
		raise self.tpg_Error(p.line)

	def tpg_eat(self, p0, regexp, split=0):
		""" skip* lex_eat """
		p1, = self.tpg_lex_skip(p0)
		return self.tpg_lex_eat(p1, regexp, split)

	def tpg_lex_skip(self, p0):
		""" skip* """
		while 1:
			try:
				p1, = self.skip(p0)
				p0 = p1
			except self.tpg_Error:
				p1 = p0
				break
			except AttributeError:
				p1 = p0
				break
		return p1,

	def tpg_lex_eat(self, p0, regexp, split=0):
		try:
			r = self.tpg_regexps[regexp]
		except KeyError:
			r = pre.compile(regexp)
			self.tpg_regexps[regexp] = r
		token = r.match(self.tpg_input, p0.pos)
		if token:
			self.line = p0.line+self.tpg_input.count('\n', p0.pos, token.end())
			p1 = self.tpg_Pos(token.end(), self.line)
			if split == 0: return p1,
			if split == 1: return p1, token.group()
			if split == 2: return p1, token.groups()
		return self.error(p0)

	def check(self, cond):
		if not cond: raise self.tpg_Error(self.line)

	def Parse(self, symbol, input, *args):
		self.setInput(input)
		return apply(getattr(self,symbol), [self.tpg_Pos()]+list(args))[1]



from string import atoi, atof, atol
from math import sqrt, cos, sin, tan, acos, asin, atan

sqr = lambda x: x*x

class Calc(ToyParser, ):
	
	def init(self):
		self.vars = {}
	def getVar(self, v):
		try:
			return self.vars[v]
		except KeyError:
			return 0
	def setVar(self, v, e):
		self.vars[v] = e
	def mem(self):
		vars = self.vars.items()
		vars.sort()
		return "\n\t" + "\n\t".join( [ "%s = %s"%(var,val) for (var,val) in vars ] )

	def __call__(self, input, *args):
		self.setInput(input)
		return apply(self.START, [self.tpg_Pos()]+list(args))[1]

	def START(self, tpg_p0, ):
		"""START -> 'vars' '$' | VarId '=' Expr '$' '$' | Expr '$' ."""
		try:
			try:
				tpg_p2,  = self.tpg_eat(tpg_p0, r'vars', 0)
				tpg_p1,  = self.tpg_eat(tpg_p2, r'$', 0)
				e=self.mem()
			except self.tpg_Error:
				tpg_p4, v = self.VarId(tpg_p0, )
				tpg_p5,  = self.tpg_eat(tpg_p4, r'=', 0)
				tpg_p6, e = self.Expr(tpg_p5, )
				tpg_p7,  = self.tpg_eat(tpg_p6, r'$', 0)
				self.setVar(v,e)
				tpg_p1,  = self.tpg_eat(tpg_p7, r'$', 0)
		except self.tpg_Error:
			tpg_p9, e = self.Expr(tpg_p0, )
			tpg_p1,  = self.tpg_eat(tpg_p9, r'$', 0)
		return tpg_p1, e

	def skip(self, tpg_p0, ):
		"""lex skip -> '\s|\n' ."""
		tpg_p1,  = self.tpg_lex_eat(tpg_p0, r'\s|\n', 0)
		return tpg_p1, 

	def VarId(self, tpg_p0, ):
		"""VarId -> '[a-zA-Z]\w*' ."""
		tpg_p1, v = self.tpg_eat(tpg_p0, r'[a-zA-Z]\w*', 1)
		return tpg_p1, v

	def Var(self, tpg_p0, ):
		"""Var -> VarId ."""
		tpg_p1, v = self.VarId(tpg_p0, )
		v=self.getVar(v)
		return tpg_p1, v

	def Expr(self, tpg_p0, ):
		"""Expr -> Term ( '\+' Term | '\-' Term )* ."""
		tpg_p2, e = self.Term(tpg_p0, )
		while 1:
			try:
				try:
					tpg_p4,  = self.tpg_eat(tpg_p2, r'\+', 0)
					tpg_p1, t = self.Term(tpg_p4, )
					e += t
				except self.tpg_Error:
					tpg_p6,  = self.tpg_eat(tpg_p2, r'\-', 0)
					tpg_p1, t = self.Term(tpg_p6, )
					e -= t
				tpg_p2 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p2
				break
		return tpg_p1, e

	def Term(self, tpg_p0, ):
		"""Term -> Fact ( '\*' Fact | '\/' Fact | '\%' Fact )* ."""
		tpg_p2, t = self.Fact(tpg_p0, )
		while 1:
			try:
				try:
					try:
						tpg_p4,  = self.tpg_eat(tpg_p2, r'\*', 0)
						tpg_p1, f = self.Fact(tpg_p4, )
						t *= f
					except self.tpg_Error:
						tpg_p6,  = self.tpg_eat(tpg_p2, r'\/', 0)
						tpg_p1, f = self.Fact(tpg_p6, )
						t /= f
				except self.tpg_Error:
					tpg_p8,  = self.tpg_eat(tpg_p2, r'\%', 0)
					tpg_p1, f = self.Fact(tpg_p8, )
					t %= f
				tpg_p2 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p2
				break
		return tpg_p1, t

	def Fact(self, tpg_p0, ):
		"""Fact -> '\-' '\-' Fact | '\-' Fact | '\+' Fact | Pow ."""
		try:
			try:
				try:
					tpg_p2,  = self.tpg_eat(tpg_p0, r'\-', 0)
					tpg_p3,  = self.tpg_eat(tpg_p2, r'\-', 0)
					tpg_p1, a = self.Fact(tpg_p3, )
				except self.tpg_Error:
					tpg_p5,  = self.tpg_eat(tpg_p0, r'\-', 0)
					tpg_p1, a = self.Fact(tpg_p5, )
					a = -a
			except self.tpg_Error:
				tpg_p7,  = self.tpg_eat(tpg_p0, r'\+', 0)
				tpg_p1, a = self.Fact(tpg_p7, )
		except self.tpg_Error:
			tpg_p1, a = self.Pow(tpg_p0, )
		return tpg_p1, a

	def Pow(self, tpg_p0, ):
		"""Pow -> Atom ( ( '\^' | '\*\*' ) Fact )* ."""
		tpg_p2, f = self.Atom(tpg_p0, )
		while 1:
			try:
				try:
					tpg_p4,  = self.tpg_eat(tpg_p2, r'\^', 0)
				except self.tpg_Error:
					tpg_p4,  = self.tpg_eat(tpg_p2, r'\*\*', 0)
				tpg_p1, e = self.Fact(tpg_p4, )
				f **= e
				tpg_p2 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p2
				break
		return tpg_p1, f

	def Atom(self, tpg_p0, ):
		"""Atom -> '(\d+\.\d*|\d*\.\d+)([eE][-+]?\d+)?' | '\d+[eE][-+]?\d+' | '\d+' | Function | Var | '\(' Expr '\)' ."""
		try:
			try:
				try:
					try:
						try:
							tpg_p1, f = self.tpg_eat(tpg_p0, r'(\d+\.\d*|\d*\.\d+)([eE][-+]?\d+)?', 1)
							a = atof(f)
						except self.tpg_Error:
							tpg_p1, f = self.tpg_eat(tpg_p0, r'\d+[eE][-+]?\d+', 1)
							a = atof(f)
					except self.tpg_Error:
						tpg_p1, i = self.tpg_eat(tpg_p0, r'\d+', 1)
						a = atol(i)
				except self.tpg_Error:
					tpg_p1, a = self.Function(tpg_p0, )
			except self.tpg_Error:
				tpg_p1, a = self.Var(tpg_p0, )
		except self.tpg_Error:
			tpg_p7,  = self.tpg_eat(tpg_p0, r'\(', 0)
			tpg_p8, a = self.Expr(tpg_p7, )
			tpg_p1,  = self.tpg_eat(tpg_p8, r'\)', 0)
		return tpg_p1, a

	def Function(self, tpg_p0, ):
		"""Function -> 'cos' '\(' Expr '\)' | 'sin' '\(' Expr '\)' | 'tan' '\(' Expr '\)' | 'acos' '\(' Expr '\)' | 'asin' '\(' Expr '\)' | 'atan' '\(' Expr '\)' | 'sqr' '\(' Expr '\)' | 'sqrt' '\(' Expr '\)' | ( 'abs' '\(' Expr '\)' | '\|' Expr '\|' ) | 'norm' '\(' Expr ',' Expr '\)' ."""
		try:
			try:
				try:
					try:
						try:
							try:
								try:
									try:
										try:
											tpg_p2,  = self.tpg_eat(tpg_p0, r'cos', 0)
											tpg_p3,  = self.tpg_eat(tpg_p2, r'\(', 0)
											tpg_p4, e = self.Expr(tpg_p3, )
											tpg_p1,  = self.tpg_eat(tpg_p4, r'\)', 0)
											f = cos(e)
										except self.tpg_Error:
											tpg_p6,  = self.tpg_eat(tpg_p0, r'sin', 0)
											tpg_p7,  = self.tpg_eat(tpg_p6, r'\(', 0)
											tpg_p8, e = self.Expr(tpg_p7, )
											tpg_p1,  = self.tpg_eat(tpg_p8, r'\)', 0)
											f = sin(e)
									except self.tpg_Error:
										tpg_p10,  = self.tpg_eat(tpg_p0, r'tan', 0)
										tpg_p11,  = self.tpg_eat(tpg_p10, r'\(', 0)
										tpg_p12, e = self.Expr(tpg_p11, )
										tpg_p1,  = self.tpg_eat(tpg_p12, r'\)', 0)
										f = tan(e)
								except self.tpg_Error:
									tpg_p14,  = self.tpg_eat(tpg_p0, r'acos', 0)
									tpg_p15,  = self.tpg_eat(tpg_p14, r'\(', 0)
									tpg_p16, e = self.Expr(tpg_p15, )
									tpg_p1,  = self.tpg_eat(tpg_p16, r'\)', 0)
									f = acos(e)
							except self.tpg_Error:
								tpg_p18,  = self.tpg_eat(tpg_p0, r'asin', 0)
								tpg_p19,  = self.tpg_eat(tpg_p18, r'\(', 0)
								tpg_p20, e = self.Expr(tpg_p19, )
								tpg_p1,  = self.tpg_eat(tpg_p20, r'\)', 0)
								f = asin(e)
						except self.tpg_Error:
							tpg_p22,  = self.tpg_eat(tpg_p0, r'atan', 0)
							tpg_p23,  = self.tpg_eat(tpg_p22, r'\(', 0)
							tpg_p24, e = self.Expr(tpg_p23, )
							tpg_p1,  = self.tpg_eat(tpg_p24, r'\)', 0)
							f = atan(e)
					except self.tpg_Error:
						tpg_p26,  = self.tpg_eat(tpg_p0, r'sqr', 0)
						tpg_p27,  = self.tpg_eat(tpg_p26, r'\(', 0)
						tpg_p28, e = self.Expr(tpg_p27, )
						tpg_p1,  = self.tpg_eat(tpg_p28, r'\)', 0)
						f = sqr(e)
				except self.tpg_Error:
					tpg_p30,  = self.tpg_eat(tpg_p0, r'sqrt', 0)
					tpg_p31,  = self.tpg_eat(tpg_p30, r'\(', 0)
					tpg_p32, e = self.Expr(tpg_p31, )
					tpg_p1,  = self.tpg_eat(tpg_p32, r'\)', 0)
					f = sqrt(e)
			except self.tpg_Error:
				try:
					tpg_p35,  = self.tpg_eat(tpg_p0, r'abs', 0)
					tpg_p36,  = self.tpg_eat(tpg_p35, r'\(', 0)
					tpg_p37, e = self.Expr(tpg_p36, )
					tpg_p1,  = self.tpg_eat(tpg_p37, r'\)', 0)
				except self.tpg_Error:
					tpg_p39,  = self.tpg_eat(tpg_p0, r'\|', 0)
					tpg_p40, e = self.Expr(tpg_p39, )
					tpg_p1,  = self.tpg_eat(tpg_p40, r'\|', 0)
				f = abs(e)
		except self.tpg_Error:
			tpg_p42,  = self.tpg_eat(tpg_p0, r'norm', 0)
			tpg_p43,  = self.tpg_eat(tpg_p42, r'\(', 0)
			tpg_p44, x = self.Expr(tpg_p43, )
			tpg_p45,  = self.tpg_eat(tpg_p44, r',', 0)
			tpg_p46, y = self.Expr(tpg_p45, )
			tpg_p1,  = self.tpg_eat(tpg_p46, r'\)', 0)
			f = sqrt(x*x+y*y)
		return tpg_p1, f



calc = Calc()
while 1:
	l = raw_input("\n:")
	if l:
		try:
			print calc(l)
		except calc.tpg_Error:
			print "erreur de syntaxe\n"
		except ZeroDivisionError:
			print "Division par zéro\n"
		except OverflowError:
			print "Résultat trop grand\n"
	else:
		break


<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>6 Lexer</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/mn.html)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/mn.html)"> 
<!-- html,2 --> 
<meta name="src" content="tpg.tex"> 
<meta name="date" content="2005-07-08 23:00:00"> 
<link rel="stylesheet" type="text/css" href="tpg.css"> 
</head><body 
>
   <!--l. 103--><div class="crosslinks"><p class="noindent">[<a 
href="tpgch7.html" >next</a>] [<a 
href="tpgch5.html" >prev</a>] [<a 
href="tpgch5.html#tailtpgch5.html" >prev-tail</a>] [<a 
href="#tailtpgch6.html">tail</a>] [<a 
href="tpgpa2.html#tpgch6.html" >up</a>] </p></div>
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;6</span><br><a 
 id="x18-390006"></a>Lexer</h2>
   <h3 class="sectionHead"><span class="titlemark">6.1   </span> <a 
 id="x18-400006.1"></a>Regular expression syntax</h3>
<!--l. 3--><p class="noindent">The lexer is based on the <span 
class="cmti-10">re</span><span class="footnote-mark"><a 
href="tpg19.html#fn1x13"><sup >1</sup></a></span><a 
 id="x18-40001f1"></a> 
module. TPG pro&#xFB01;ts from the power of Python regular expressions. This document assumes the reader is
familiar with regular expressions.
<!--l. 7--><p class="indent">   You can use the syntax of regular expressions as expected by the <span 
class="cmti-10">re </span>module except from the grouping
by name syntax since it is used by TPG to decide which token is recognized.
<!--l. 9--><p class="indent">   Here is a summary<span class="footnote-mark"><a 
href="tpg20.html#fn2x13"><sup >2</sup></a></span><a 
 id="x18-40002f2"></a> 
of the regular expression syntax:
     <dl class="description"><dt class="description">
<span 
class="cmbx-10">&#8221;.&#8221;</span> </dt><dd 
class="description">(Dot.) In the default mode, this matches any character except a newline. If the <span 
class="cmti-10">DOTALL </span>&#xFB02;ag
     has been speci&#xFB01;ed, this matches any character including a newline.
     </dd><dt class="description">
<span 
class="cmbx-10">&#8221;</span><img 
src="tpg0x.png" alt="&#x02C6;"  class="circ" > <span 
class="cmbx-10">&#8221;</span> </dt><dd 
class="description">(Caret.) Matches the start of the string, and in <span 
class="cmti-10">MULTILINE </span>mode also matches immediately
     after each newline.
     </dd><dt class="description">
<span 
class="cmbx-10">&#8221;$&#8221;</span> </dt><dd 
class="description">Matches the end of the string or just before the newline at the end of the string, and in
     <span 
class="cmti-10">MULTILINE </span>mode also matches before a newline. <span 
class="cmmi-10">foo </span>matches both &#8217;foo&#8217; and &#8217;foobar&#8217;, while
     the regular expression <span 
class="cmmi-10">foo</span>$ matches only &#8217;foo&#8217;. More interestingly, searching for <span 
class="cmmi-10">foo.</span>$ in
     &#8217;foo1<span 
class="cmsy-10">\</span>nfoo2<span 
class="cmsy-10">\</span>n&#8217; matches &#8217;foo2&#8217; normally, but &#8217;foo1&#8217; in <span 
class="cmti-10">MULTILINE </span>mode.
     </dd><dt class="description">
<span 
class="cmbx-10">&#8221;*&#8221;</span> </dt><dd 
class="description">Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many
     repetitions as are possible. <span 
class="cmmi-10">ab</span><span 
class="cmsy-10">* </span>will match &#8217;a&#8217;, &#8217;ab&#8217;, or &#8217;a&#8217; followed by any number of &#8217;b&#8217;s.
     </dd><dt class="description">
<span 
class="cmbx-10">&#8221;+&#8221;</span> </dt><dd 
class="description">Causes the resulting RE to match 1 or more repetitions of the preceding RE. <span 
class="cmmi-10">ab</span>+ will match
     &#8217;a&#8217; followed by any non-zero number of &#8217;b&#8217;s; it will not match just &#8217;a&#8217;.
     </dd><dt class="description">
<span 
class="cmbx-10">&#8221;?&#8221;</span> </dt><dd 
class="description">Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. <span 
class="cmmi-10">ab</span>? will match
     either &#8217;a&#8217; or &#8217;ab&#8217;.
     </dd><dt class="description">
<span 
class="cmbx-10">*?, +?, ??</span> </dt><dd 
class="description">The  &#8221;*&#8221;,  &#8221;+&#8221;,  and  &#8221;?&#8221;  quali&#xFB01;ers  are  all  greedy;  they  match  as  much  text  as
     possible.  Sometimes  this  behaviour  isn&#8217;t  desired;  if  the  RE  <span 
class="cmmi-10">&lt; .</span><span 
class="cmsy-10">* </span><span 
class="cmmi-10">&gt; </span>is  matched  against
     &#8217;<span 
class="cmmi-10">&lt;</span>H1<span 
class="cmmi-10">&gt;</span>title<span 
class="cmmi-10">&lt;</span>/H1<span 
class="cmmi-10">&gt;</span>&#8217;, it will match the entire string, and not just &#8217;<span 
class="cmmi-10">&lt;</span>H1<span 
class="cmmi-10">&gt;</span>&#8217;. Adding &#8221;?&#8221; after
     the quali&#xFB01;er makes it perform the match in non-greedy or minimal fashion; as few characters
     as possible will be matched. Using <span 
class="cmmi-10">.</span><span 
class="cmsy-10">*</span>? in the previous expression will match only &#8217;<span 
class="cmmi-10">&lt;</span>H1<span 
class="cmmi-10">&gt;</span>&#8217;.
     </dd><dt class="description">
<span 
class="cmsy-10">{</span><span 
class="cmbx-10">m</span><span 
class="cmsy-10">}</span> </dt><dd 
class="description">Speci&#xFB01;es that exactly m copies of the previous RE should be matched; fewer matches cause
     the entire RE not to match. For example, <span 
class="cmmi-10">a</span><span 
class="cmsy-10">{</span>6<span 
class="cmsy-10">} </span>will match exactly six &#8221;a&#8221; characters, but
     not &#xFB01;ve.
                                                                                 

                                                                                 
     </dd><dt class="description">
<span 
class="cmsy-10">{</span><span 
class="cmbx-10">m,n</span><span 
class="cmsy-10">}</span> </dt><dd 
class="description">Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting
     to match as many repetitions as possible. For example, <span 
class="cmmi-10">a</span><span 
class="cmsy-10">{</span>3<span 
class="cmmi-10">,</span>5<span 
class="cmsy-10">} </span>will match from 3 to 5 &#8221;a&#8221;
     characters. Omitting m speci&#xFB01;es a lower bound of zero, and omitting n speci&#xFB01;es an in&#xFB01;nite
     upper bound. As an example, <span 
class="cmmi-10">a</span><span 
class="cmsy-10">{</span>4<span 
class="cmmi-10">,</span><span 
class="cmsy-10">}</span><span 
class="cmmi-10">b </span>will match aaaab or a thousand &#8221;a&#8221; characters followed
     by a b, but not aaab. The comma may not be omitted or the modi&#xFB01;er would be confused
     with the previously described form.
     </dd><dt class="description">
<span 
class="cmbsy-10">{</span><span 
class="cmbx-10">m,n</span><span 
class="cmbsy-10">}</span><span 
class="cmbx-10">?</span> </dt><dd 
class="description">Causes  the  resulting  RE  to  match  from  m  to  n  repetitions  of  the  preceding  RE,
     attempting to match as few repetitions as possible. This is the non-greedy version of the
     previous quali&#xFB01;er. For example, on the 6-character string &#8217;aaaaaa&#8217;, <span 
class="cmmi-10">a</span><span 
class="cmsy-10">{</span>3<span 
class="cmmi-10">,</span>5<span 
class="cmsy-10">} </span>will match 5 &#8221;a&#8221;
     characters, while <span 
class="cmmi-10">a</span><span 
class="cmsy-10">{</span>3<span 
class="cmmi-10">,</span>5<span 
class="cmsy-10">}</span>? will only match 3 characters.
     </dd><dt class="description">
<span 
class="cmbx-10">&#8221;</span><span 
class="cmsy-10">\</span><span 
class="cmbx-10">&#8221;</span> </dt><dd 
class="description">Either escapes special characters (permitting you to match characters like &#8221;*&#8221;, &#8221;?&#8221;, and so
     forth), or signals a special sequence; special sequences are discussed below.
     </dd><dt class="description">
[] </dt><dd 
class="description">Used to indicate a set of characters. Characters can be listed individually, or a range of characters
     can be indicated by giving two characters and separating them by a &#8221;-&#8221;. Special characters
     are not active inside sets. For example, [<span 
class="cmmi-10">akm</span>$] will match any of the characters &#8221;a&#8221;, &#8221;k&#8221;,
     &#8221;m&#8221;, or &#8221;$&#8221;; [<span 
class="cmmi-10">a </span><span 
class="cmsy-10">- </span><span 
class="cmmi-10">z</span>] will match any lowercase letter, and [<span 
class="cmmi-10">a </span><span 
class="cmsy-10">- </span><span 
class="cmmi-10">zA </span><span 
class="cmsy-10">- </span><span 
class="cmmi-10">Z</span>0 <span 
class="cmsy-10">- </span>9] matches any
     letter or digit. Character classes such as <span 
class="cmsy-10">\</span>w or <span 
class="cmsy-10">\</span>S (de&#xFB01;ned below) are also acceptable inside
     a range. If you want to include a &#8221;]&#8221; or a &#8221;-&#8221; inside a set, precede it with a backslash, or
     place it as the &#xFB01;rst character. The pattern []] will match &#8217;]&#8217;, for example.
     <!--l. 37--><p class="noindent">You can match the characters not within a range by complementing the set. This is indicated
     by including a &#8221;<img 
src="tpg1x.png" alt="&#x02C6;"  class="circ" > &#8221; as the &#xFB01;rst character of the set; &#8221;<img 
src="tpg2x.png" alt="&#x02C6;"  class="circ" > &#8221; elsewhere will simply match the &#8221;<img 
src="tpg3x.png" alt="&#x02C6;"  class="circ" > &#8221;
     character. For example, [<img 
src="tpg4x.png" alt="&#x02C6;"  class="circ" > 5] will match any character except &#8221;5&#8221;, and [<img 
src="tpg5x.png" alt="&#x02C6;"  class="circ" > <img 
src="tpg6x.png" alt="&#x02C6;"  class="circ" > ] will match any
     character except &#8221;<img 
src="tpg7x.png" alt="&#x02C6;"  class="circ" > &#8221;.
     </dd><dt class="description">
<span 
class="cmbx-10">&#8221;</span><span 
class="cmsy-10">&#x2223;</span><span 
class="cmbx-10">&#8221;</span> </dt><dd 
class="description"><span 
class="cmmi-10">A</span><span 
class="cmsy-10">&#x2223;</span><span 
class="cmmi-10">B</span>, where <span 
class="cmmi-10">A </span>and <span 
class="cmmi-10">B </span>can be arbitrary REs, creates a regular expression that will match either
     A or B. An arbitrary number of REs can be separated by the &#8221;<span 
class="cmsy-10">&#x2223;</span>&#8221; in this way. This can be
     used inside groups (see below) as well. As the target string is scanned, REs separated by &#8221;<span 
class="cmsy-10">&#x2223;</span>&#8221;
     are tried from left to right. When one pattern completely matches, that branch is accepted.
     This means that once A matches, B will not be tested further, even if it would produce a
     longer overall match. In other words, the &#8221;<span 
class="cmsy-10">&#x2223;</span>&#8221; operator is never greedy. To match a literal &#8221;<span 
class="cmsy-10">&#x2223;</span>&#8221;,
     use <span 
class="cmsy-10">\&#x2223;</span>, or enclose it inside a character class, as in [<span 
class="cmsy-10">&#x2223;</span>].
     </dd><dt class="description">
<span 
class="cmbx-10">(...)</span> </dt><dd 
class="description">Matches whatever regular expression is inside the parentheses, and indicates the start and
     end of a group; the contents of a group can be retrieved after a match has been performed,
     and can be matched later in the string with the <span 
class="cmsy-10">\</span><span 
class="cmmi-10">number </span>special sequence, described below.
     To match the literals &#8221;(&#8221; or &#8221;)&#8221;, use <span 
class="cmsy-10">\</span>( or <span 
class="cmsy-10">\</span>), or enclose them inside a character class: [(] [)].
     </dd><dt class="description">
<span 
class="cmbx-10">(?=...)</span> </dt><dd 
class="description">Matches if ... matches next, but doesn&#8217;t consume any of the string. This is called a
     lookahead assertion. For example, <span 
class="cmmi-10">Isaac</span>(? = <span 
class="cmmi-10">Asimov</span>) will match &#8217;Isaac &#8217; only if it&#8217;s followed
     by &#8217;Asimov&#8217;.
     </dd><dt class="description">
<span 
class="cmbx-10">(?!...)</span> </dt><dd 
class="description">Matches if ... doesn&#8217;t match next. This is a negative lookahead assertion. For example,
     <span 
class="cmmi-10">Isaac</span>(?!<span 
class="cmmi-10">Asimov</span>) will match &#8217;Isaac &#8217; only if it&#8217;s not followed by &#8217;Asimov&#8217;.
                                                                                 

                                                                                 
     </dd><dt class="description">
<span 
class="cmbx-10">(?</span><span 
class="cmmi-10">&lt;</span><span 
class="cmbx-10">=...)</span> </dt><dd 
class="description">Matches if the current position in the string is preceded by a match for ... that ends
     at the current position. This is called a positive lookbehind assertion. (? <span 
class="cmmi-10">&lt;</span>= <span 
class="cmmi-10">abc</span>)<span 
class="cmmi-10">def </span>will
     &#xFB01;nd a match in &#8221;abcdef&#8221;, since the lookbehind will back up 3 characters and check if the
     contained pattern matches. The contained pattern must only match strings of some &#xFB01;xed
     length, meaning that <span 
class="cmmi-10">abc </span>or <span 
class="cmmi-10">a</span><span 
class="cmsy-10">&#x2223;</span><span 
class="cmmi-10">b </span>are allowed, but <span 
class="cmmi-10">a</span><span 
class="cmsy-10">* </span>and <span 
class="cmmi-10">a</span><span 
class="cmsy-10">{</span>3<span 
class="cmmi-10">,</span>4<span 
class="cmsy-10">} </span>are not.
     </dd><dt class="description">
<span 
class="cmbx-10">(?</span><span 
class="cmmi-10">&lt;</span><span 
class="cmbx-10">!...)</span> </dt><dd 
class="description">Matches if the current position in the string is not preceded by a match for .... This
     is  called  a  negative  lookbehind  assertion.  Similar  to  positive  lookbehind  assertions,  the
     contained pattern must only match strings of some &#xFB01;xed length. Patterns which start with
     negative lookbehind assertions may match at the beginning of the string being searched.
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">A</span> </dt><dd 
class="description">Matches only at the start of the string.
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">b</span> </dt><dd 
class="description">Matches the empty string, but only at the beginning or end of a word. A word is de&#xFB01;ned as
     a sequence of alphanumeric or underscore characters, so the end of a word is indicated by
     whitespace or a non-alphanumeric, non-underscore character. Note that <span 
class="cmsy-10">\</span><span 
class="cmmi-10">b </span>is de&#xFB01;ned as the
     boundary between <span 
class="cmsy-10">\</span><span 
class="cmmi-10">w </span>and <span 
class="cmsy-10">\</span><span 
class="cmmi-10">W</span>, so the precise set of characters deemed to be alphanumeric
     depends on the values of the UNICODE and LOCALE &#xFB02;ags. Inside a character range, <span 
class="cmsy-10">\</span><span 
class="cmmi-10">b</span>
     represents the backspace character, for compatibility with Python&#8217;s string literals.
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">B</span> </dt><dd 
class="description">Matches the empty string, but only when it is not at the beginning or end of a word. This is
     just the opposite of <span 
class="cmsy-10">\</span><span 
class="cmmi-10">b</span>, so is also subject to the settings of LOCALE and UNICODE.
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">d</span> </dt><dd 
class="description">Matches any decimal digit; this is equivalent to the set [0 <span 
class="cmsy-10">- </span>9].
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">D</span> </dt><dd 
class="description">Matches any non-digit character; this is equivalent to the set [<img 
src="tpg8x.png" alt="&#x02C6;"  class="circ" > 0 <span 
class="cmsy-10">- </span>9].
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">s</span> </dt><dd 
class="description">Matches any whitespace character; this is equivalent to the set [<span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">t</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">n</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">r</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">f</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">v</span>].
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">S</span> </dt><dd 
class="description">Matches any non-whitespace character; this is equivalent to the set [<img 
src="tpg9x.png" alt="&#x02C6;"  class="circ" > <span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">t</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">n</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">r</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">f</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">v</span>].
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">w</span> </dt><dd 
class="description">When  the  LOCALE  and  UNICODE  &#xFB02;ags  are  not  speci&#xFB01;ed,  matches  any  alphanumeric
     character and the underscore; this is equivalent to the set [<span 
class="cmmi-10">a</span><span 
class="cmsy-10">-</span><span 
class="cmmi-10">zA</span><span 
class="cmsy-10">-</span><span 
class="cmmi-10">Z</span>0<span 
class="cmsy-10">-</span>9_]. With LOCALE,
     it will match the set [0 <span 
class="cmsy-10">- </span>9_] plus whatever characters are de&#xFB01;ned as alphanumeric for the
     current locale. If UNICODE is set, this will match the characters [0 <span 
class="cmsy-10">- </span>9_] plus whatever is
     classi&#xFB01;ed as alphanumeric in the Unicode character properties database.
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">W</span> </dt><dd 
class="description">When the LOCALE and UNICODE &#xFB02;ags are not speci&#xFB01;ed, matches any non-alphanumeric
     character; this is equivalent to the set [<img 
src="tpg10x.png" alt="&#x02C6;"  class="circ" > <span 
class="cmmi-10">a </span><span 
class="cmsy-10">- </span><span 
class="cmmi-10">zA </span><span 
class="cmsy-10">- </span><span 
class="cmmi-10">Z</span>0 <span 
class="cmsy-10">- </span>9_]. With LOCALE, it will match
     any character not in the set [0 <span 
class="cmsy-10">- </span>9_], and not de&#xFB01;ned as alphanumeric for the current locale.
     If UNICODE is set, this will match anything other than [0 <span 
class="cmsy-10">- </span>9_] and characters marked as
     alphanumeric in the Unicode character properties database.
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">Z</span> </dt><dd 
class="description">Matches only at the end of the string.
                                                                                 

                                                                                 
     </dd><dt class="description">
<span 
class="cmsy-10">\</span><span 
class="cmmi-10">a</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">f</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">n</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">r</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">t</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">v</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">x</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\\</span> </dt><dd 
class="description">Most of the standard escapes supported by Python string literals are
     also accepted by the regular expression parser.
     </dd><dt class="description">
<span 
class="cmsy-10">\</span>0<span 
class="cmmi-10">xyz</span><span 
class="cmbx-10">, </span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">xyz</span> </dt><dd 
class="description">Octal escapes are included in a limited form: If the &#xFB01;rst digit is a 0, or if there are
     three octal digits, it is considered an octal escape. As for string literals, octal escapes are
     always at most three digits in length.</dd></dl>
   <h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
 id="x18-410006.2"></a>Token de&#xFB01;nition</h3>
<!--l. 77--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
 id="x18-420006.2.1"></a>Prede&#xFB01;ned tokens</h4>
<!--l. 79--><p class="noindent">Tokens can be explicitely de&#xFB01;ned by the <span 
class="cmti-10">token </span>and <span 
class="cmti-10">separator </span>keywords.
<!--l. 81--><p class="indent">   A token is de&#xFB01;ned by:
     <dl class="description"><dt class="description">
<span 
class="cmbx-10">a name</span> </dt><dd 
class="description">which identi&#xFB01;es the token. This name is used by the parser.
     </dd><dt class="description">
<span 
class="cmbx-10">a regular expression</span> </dt><dd 
class="description">which describes what to match to recognize the token.
     </dd><dt class="description">
<span 
class="cmbx-10">an action</span> </dt><dd 
class="description">which can translate the matched text into a Python object. It can be a function of
     one argument or a non callable object. If it is not callable, it will be returned for each token
     otherwise it will be applied to the text of the token and the result will be returned. This
     action is optional. By default the token text is returned.</dd></dl>
<!--l. 90--><p class="indent">   Token de&#xFB01;nitions must end with a <span 
class="cmti-10">; </span>when no action is speci&#xFB01;ed. The dots after the token name are
optional.
<!--l. 92--><p class="indent">   See &#xFB01;gure&#x00A0;<a 
href="#x18-420011">6.1<!--tex4ht:ref: lexer:tokens --></a> for examples.
<!--l. 94--><p class="indent">   <hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                 

                                                                                 
<a 
 id="x18-420011"></a>
                                                                                 

                                                                                 
   <div class="tabular"><table class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
frame="border" id="TBL-15-" ><colgroup id="TBL-15-1g"><col 
id="TBL-15-1"></colgroup><tr 
class="hline"><td><hr></td></tr><tr  
 valign="baseline" id="TBL-15-1-"><td  style="text-align:left;" id="TBL-15-1-1"  
class="td11"><br> <table class="caption" 
><tr valign="baseline" class="caption"><td class="id">Figure&#x00A0;6.1: </td><td  
class="content">Token de&#xFB01;nition examples</td></tr></table><!--tex4ht:label?: x18-420011 -->
<table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;name&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;reg.&#x00A0;exp&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;action
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;token&#x00A0;integer:&#x00A0;&#8217;\d+&#8217;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;token&#x00A0;ident&#x00A0;&#x00A0;:&#x00A0;&#8217;[a-zA-Z]\w*&#8217;&#x00A0;&#x00A0;&#x00A0;;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;token&#x00A0;bool&#x00A0;&#x00A0;&#x00A0;:&#x00A0;&#8217;True|False&#8217;&#x00A0;&#x00A0;&#x00A0;&#x00A0;$&#x00A0;lambda&#x00A0;b:&#x00A0;b==&#8217;True&#8217;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;separator&#x00A0;spaces&#x00A0;&#x00A0;:&#x00A0;&#8217;\s+&#8217;;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;white&#x00A0;spaces
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;separator&#x00A0;comments:&#x00A0;&#8217;#.*&#8217;;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;#&#x00A0;comments
</div>
</td></tr></table>
<!--l. 104--><p class="nopar">                                                                                 </td>
</tr><tr 
class="hline"><td><hr></td></tr><tr  
 valign="baseline" id="TBL-15-2-"><td  style="text-align:left;" id="TBL-15-2-1"  
class="td11">                                                                                                                               </td> </tr></table>
</div>
                                                                                 

                                                                                 
<!--l. 105--><p class="indent">   </td></tr></table></div><hr class="endfigure">
<!--l. 107--><p class="indent">   The order of the declaration of the tokens is important. The &#xFB01;rst token that is matched is returned.
The regular expression has a special treatment. If it describes a keyword, TPG also looks for a word
boundary after the keyword. If you try to match the keywords <span 
class="cmti-10">if  </span>and <span 
class="cmti-10">ifxyz </span>TPG will internally
search <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">if\b</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">ifxyz\b</span></span></span>. This way, <span 
class="cmti-10">if  </span>won&#8217;t match <span 
class="cmti-10">ifxyz </span>and won&#8217;t interfere with general
identi&#xFB01;ers (<span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">\w+</span></span></span> for example). This behaviour can be disabled since the version 3 of TPG
(see&#x00A0;<a 
href="tpgch5.html#x17-310005.3.2">5.3.2<!--tex4ht:ref: grammar:word_boundary_option --></a>).
<!--l. 109--><p class="indent">   There are two kinds of tokens. Tokens de&#xFB01;ned by the <span 
class="cmti-10">token </span>keyword are parsed by the parser and
tokens de&#xFB01;ned by the <span 
class="cmti-10">separator </span>keyword are considered as separators (white spaces or comments for
example) and are wiped out by the lexer.
   <h4 class="subsectionHead"><span class="titlemark">6.2.2   </span> <a 
 id="x18-430006.2.2"></a>Inline tokens</h4>
<!--l. 113--><p class="noindent">Tokens can also be de&#xFB01;ned on the &#xFB02;y. Their de&#xFB01;nition are then inlined in the grammar rules. This feature
may be useful for keywords or punctuation signs. Inline tokens can not be transformed by an action as
prede&#xFB01;ned tokens. They always return the token in a string.
<!--l. 118--><p class="indent">   See &#xFB01;gure&#x00A0;<a 
href="#x18-430012">6.2<!--tex4ht:ref: lexer:inline_tokens --></a> for examples.
<!--l. 120--><p class="indent">   <hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                 

                                                                                 
<a 
 id="x18-430012"></a>
                                                                                 

                                                                                 
   <div class="tabular"><table class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
frame="border" id="TBL-16-" ><colgroup id="TBL-16-1g"><col 
id="TBL-16-1"></colgroup><tr 
class="hline"><td><hr></td></tr><tr  
 valign="baseline" id="TBL-16-1-"><td  style="text-align:left;" id="TBL-16-1-1"  
class="td11"><br> <table class="caption" 
><tr valign="baseline" class="caption"><td class="id">Figure&#x00A0;6.2: </td><td  
class="content">Inline token de&#xFB01;nition examples</td></tr></table><!--tex4ht:label?: x18-430012 -->
<table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;IfThenElse&#x00A0;-&gt;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8217;if&#8217;&#x00A0;Cond
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8217;then&#8217;&#x00A0;Statement
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#8217;else&#8217;&#x00A0;Statement
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;;
</div>
</td></tr></table>
<!--l. 128--><p class="nopar">                                                                                 </td>
</tr><tr 
class="hline"><td><hr></td></tr><tr  
 valign="baseline" id="TBL-16-2-"><td  style="text-align:left;" id="TBL-16-2-1"  
class="td11">                                                                                                                               </td> </tr></table>
</div>
                                                                                 

                                                                                 
<!--l. 129--><p class="indent">   </td></tr></table></div><hr class="endfigure">
<!--l. 131--><p class="indent">   Inline tokens have a higher precedence than prede&#xFB01;ned tokens to avoid con&#xFB02;icts (an inlined <span 
class="cmti-10">if </span>won&#8217;t
be matched as a prede&#xFB01;ned <span 
class="cmti-10">identi&#xFB01;er</span>).
   <h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x18-440006.3"></a>Token matching</h3>
<!--l. 135--><p class="noindent">TPG works in two stages. The lexer &#xFB01;rst splits the input string into a list of tokens and then the parser
parses this list. The default lexer is lazy in TPG 3. Tokens are generated while parsing. This way TPG 3
need less memory when parsing huge &#xFB01;les.
<!--l. 140--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">6.3.1   </span> <a 
 id="x18-450006.3.1"></a>Splitting the input string</h4>
<!--l. 142--><p class="noindent">The lexer split the input string according to the token de&#xFB01;nitions (see&#x00A0;<a 
href="#x18-410006.2">6.2<!--tex4ht:ref: lexer:token_def --></a>). When the input string can
not be matched a <span 
class="cmti-10">tpg.LexicalError </span>exception is raised.
<!--l. 144--><p class="indent">   The lexer may loop inde&#xFB01;nitely if a token can match an empty string since empty strings are
everywhere.
<!--l. 146--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">6.3.2   </span> <a 
 id="x18-460006.3.2"></a>Matching tokens in grammar rules</h4>
<!--l. 148--><p class="noindent">Tokens are matched as symbols are recognized. Prede&#xFB01;ned tokens have the same syntax than non
terminal symbols. The token text (or the result of the function associated to the token) can be saved by
the in&#xFB01;x <span 
class="cmti-10">/ </span>operator (see &#xFB01;gure&#x00A0;<a 
href="#x18-460013">6.3<!--tex4ht:ref: lexer:token_ret_val --></a>).
<!--l. 152--><p class="indent">   <hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                 

                                                                                 
<a 
 id="x18-460013"></a>
                                                                                 

                                                                                 
   <div class="tabular"><table class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
frame="border" id="TBL-17-" ><colgroup id="TBL-17-1g"><col 
id="TBL-17-1"></colgroup><tr 
class="hline"><td><hr></td></tr><tr  
 valign="baseline" id="TBL-17-1-"><td  style="text-align:left;" id="TBL-17-1-1"  
class="td11"><br> <table class="caption" 
><tr valign="baseline" class="caption"><td class="id">Figure&#x00A0;6.3: </td><td  
class="content">Token usage examples</td></tr></table><!--tex4ht:label?: x18-460013 -->
<table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;S&#x00A0;-&gt;&#x00A0;ident/i;
</div>
</td></tr></table>
<!--l. 156--><p class="nopar">                                                                                 </td>
</tr><tr 
class="hline"><td><hr></td></tr><tr  
 valign="baseline" id="TBL-17-2-"><td  style="text-align:left;" id="TBL-17-2-1"  
class="td11">                                                                                                                               </td> </tr></table>
</div>
                                                                                 

                                                                                 
<!--l. 157--><p class="indent">   </td></tr></table></div><hr class="endfigure">
<!--l. 159--><p class="indent">   Inline tokens have a similar syntax. You just write the regular expression (in a string). Its text can
also be saved (see &#xFB01;gure&#x00A0;<a 
href="#x18-460024">6.4<!--tex4ht:ref: lexer:inline_token_ret_val --></a>).
<!--l. 161--><p class="indent">   <hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                 

                                                                                 
<a 
 id="x18-460024"></a>
                                                                                 

                                                                                 
   <div class="tabular"><table class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
frame="border" id="TBL-18-" ><colgroup id="TBL-18-1g"><col 
id="TBL-18-1"></colgroup><tr 
class="hline"><td><hr></td></tr><tr  
 valign="baseline" id="TBL-18-1-"><td  style="text-align:left;" id="TBL-18-1-1"  
class="td11"><br> <table class="caption" 
><tr valign="baseline" class="caption"><td class="id">Figure&#x00A0;6.4: </td><td  
class="content">Token usage examples</td></tr></table><!--tex4ht:label?: x18-460024 -->
<table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;S&#x00A0;-&gt;&#x00A0;&#8217;(&#8217;&#x00A0;&#8217;\w+&#8217;/i&#x00A0;&#8217;)&#8217;;
</div>
</td></tr></table>
<!--l. 165--><p class="nopar">                                                                                 </td>
</tr><tr 
class="hline"><td><hr></td></tr><tr  
 valign="baseline" id="TBL-18-2-"><td  style="text-align:left;" id="TBL-18-2-1"  
class="td11">                                                                                                                               </td> </tr></table>
</div>
                                                                                 

                                                                                 
<!--l. 166--><p class="indent">   </td></tr></table></div><hr class="endfigure">
                                                                                 

                                                                                 
   <!--l. 105--><div class="crosslinks"><p class="noindent">[<a 
href="tpgch7.html" >next</a>] [<a 
href="tpgch5.html" >prev</a>] [<a 
href="tpgch5.html#tailtpgch5.html" >prev-tail</a>] [<a 
href="tpgch6.html" >front</a>] [<a 
href="tpgpa2.html#tpgch6.html" >up</a>] </p></div>
<!--l. 105--><p class="indent">   <a 
 id="tailtpgch6.html"></a>    
</body></html> 
